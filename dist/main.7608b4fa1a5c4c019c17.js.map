{"version":3,"file":"main.7608b4fa1a5c4c019c17.js","mappings":"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","sources":["webpack://png-metadata-extractor/./src/png-analyzer.ts","webpack://png-metadata-extractor/./src/image-preview.ts","webpack://png-metadata-extractor/./src/main.ts"],"sourcesContent":["import type { PNGMetadata, PNGImageInfo, PNGTextMetadata, PNGTimestamp, ColorTypes } from \"./types\"\r\n\r\n/**\r\n * PNG画像ファイルの詳細解析を行うクラス\r\n * バイナリレベルでPNGの構造を解析し、メタデータを抽出する\r\n */\r\nexport class PNGAnalyzer {\r\n  /** PNG色タイプの定義（PNG仕様に基づく） */\r\n  private colorTypes: ColorTypes = {\r\n    0: \"グレースケール\",\r\n    2: \"RGB\",\r\n    3: \"パレット\",\r\n    4: \"グレースケール + アルファ\",\r\n    6: \"RGB + アルファ\",\r\n  }\r\n\r\n  /**\r\n   * ファイルから指定範囲のバイトデータを読み取る\r\n   * @param file - 読み取り対象のファイル\r\n   * @param start - 開始位置（バイト）\r\n   * @param length - 読み取り長さ（バイト）\r\n   * @returns バイトデータの配列\r\n   */\r\n  async readBytes(file: File, start: number, length: number): Promise<Uint8Array> {\r\n    const slice = file.slice(start, start + length)\r\n    const buffer = await slice.arrayBuffer()\r\n    return new Uint8Array(buffer)\r\n  }\r\n\r\n  /**\r\n   * バイト配列を32ビット符号なし整数に変換（ビッグエンディアン）\r\n   * @param bytes - バイト配列\r\n   * @param offset - 開始オフセット\r\n   * @returns 32ビット整数値\r\n   */\r\n  bytesToUint32(bytes: Uint8Array, offset = 0): number {\r\n    if (offset + 3 >= bytes.length) return 0\r\n    const b0 = bytes[offset]\r\n    const b1 = bytes[offset + 1]\r\n    const b2 = bytes[offset + 2]\r\n    const b3 = bytes[offset + 3]\r\n    if (b0 == null || b1 == null || b2 == null || b3 == null) return 0\r\n    return (b0 << 24) | (b1 << 16) | (b2 << 8) | b3\r\n  }\r\n\r\n  /**\r\n   * バイト配列を16ビット符号なし整数に変換（ビッグエンディアン）\r\n   * @param bytes - バイト配列\r\n   * @param offset - 開始オフセット\r\n   * @returns 16ビット整数値\r\n   */\r\n  bytesToUint16(bytes: Uint8Array, offset = 0): number {\r\n    if (offset + 1 >= bytes.length) return 0\r\n    const b0 = bytes[offset]\r\n    const b1 = bytes[offset + 1]\r\n    if (b0 == null || b1 == null) return 0\r\n    return (b0 << 8) | b1\r\n  }\r\n\r\n  /**\r\n   * バイト配列を文字列に変換\r\n   * @param bytes - バイト配列\r\n   * @param start - 開始位置\r\n   * @param end - 終了位置（省略時は配列の最後まで）\r\n   * @returns 変換された文字列\r\n   */\r\n  bytesToString(bytes: Uint8Array, start = 0, end?: number): string {\r\n    const slice = end ? bytes.slice(start, end) : bytes.slice(start)\r\n    return Array.from(slice)\r\n      .map((b) => String.fromCharCode(b))\r\n      .join(\"\")\r\n  }\r\n\r\n  /**\r\n   * バイト配列を16進数文字列に変換\r\n   * @param bytes - バイト配列\r\n   * @returns 16進数文字列（例: \"89504e47\"）\r\n   */\r\n  bytesToHex(bytes: Uint8Array): string {\r\n    return Array.from(bytes)\r\n      .map((b) => b.toString(16).padStart(2, \"0\"))\r\n      .join(\"\")\r\n  }\r\n\r\n  /**\r\n   * IHDRチャンク（画像ヘッダー）を解析\r\n   * PNG画像の基本情報（幅、高さ、色深度など）を抽出\r\n   * @param data - IHDRチャンクのデータ部分\r\n   * @returns 画像情報オブジェクト\r\n   */\r\n  parseIHDR(data: Uint8Array): PNGImageInfo {\r\n    if (data.length < 13) {\r\n      throw new Error(\"IHDRチャンクのデータが不正です\")\r\n    }\r\n\r\n    const bitDepth = data[8]\r\n    const colorTypeValue = data[9]\r\n    const compressionMethod = data[10]\r\n    const filterMethod = data[11]\r\n    const interlaceMethod = data[12]\r\n\r\n    if (\r\n      bitDepth == null ||\r\n      colorTypeValue == null ||\r\n      compressionMethod == null ||\r\n      filterMethod == null ||\r\n      interlaceMethod == null\r\n    ) {\r\n      throw new Error(\"IHDRチャンクのデータが不正です\")\r\n    }\r\n\r\n    return {\r\n      width: this.bytesToUint32(data, 0), // 画像の幅（ピクセル）\r\n      height: this.bytesToUint32(data, 4), // 画像の高さ（ピクセル）\r\n      bitDepth, // ビット深度（1, 2, 4, 8, 16）\r\n      colorType: this.colorTypes[colorTypeValue as keyof ColorTypes] || `不明 (${colorTypeValue})`, // 色タイプ\r\n      compressionMethod, // 圧縮方式（常に0）\r\n      filterMethod, // フィルター方式（常に0）\r\n      interlaceMethod, // インターレース方式（0=なし, 1=Adam7）\r\n    }\r\n  }\r\n\r\n  /**\r\n   * テキストチャンク（tEXt, iTXt）を解析\r\n   * PNG内に埋め込まれたテキストメタデータを抽出\r\n   * @param data - テキストチャンクのデータ部分\r\n   * @param chunkType - チャンクタイプ（\"tEXt\" または \"iTXt\"）\r\n   * @returns テキストメタデータオブジェクト\r\n   */\r\n  parseTextChunk(data: Uint8Array, chunkType: string): PNGTextMetadata {\r\n    const result: PNGTextMetadata = {}\r\n\r\n    try {\r\n      if (chunkType === \"tEXt\") {\r\n        // tEXtチャンク: キーワード\\0テキスト の形式\r\n        const nullIndex = data.indexOf(0) // null文字の位置を検索\r\n        if (nullIndex !== -1) {\r\n          const keyword = this.bytesToString(data, 0, nullIndex)\r\n          const text = this.bytesToString(data, nullIndex + 1)\r\n          result[keyword] = text\r\n        }\r\n      } else if (chunkType === \"iTXt\") {\r\n        // iTXtチャンク: より複雑な国際化テキスト形式\r\n        const parts: number[] = []\r\n\r\n        // null文字の位置を4つまで検索\r\n        for (let i = 0; i < data.length && parts.length < 4; i++) {\r\n          if (data[i] === 0) {\r\n            parts.push(i)\r\n          }\r\n        }\r\n\r\n        if (parts.length >= 4) {\r\n          const keyword = this.bytesToString(data, 0, parts[0]) // キーワード\r\n          const compressionFlagByte = parts[0] != null && parts[0] + 1 < data.length ? data[parts[0] + 1] : undefined\r\n          const compressionFlag = compressionFlagByte != null ? compressionFlagByte : 0 // 圧縮フラグ\r\n          const languageTag =\r\n            parts[1] != null && parts[2] != null ? this.bytesToString(data, parts[1] + 1, parts[2]) : \"\" // 言語タグ\r\n          const translatedKeyword =\r\n            parts[2] != null && parts[3] != null ? this.bytesToString(data, parts[2] + 1, parts[3]) : \"\" // 翻訳されたキーワード\r\n          const text = parts[3] != null ? this.bytesToString(data, parts[3] + 1) : \"\" // テキスト本体\r\n\r\n          result[keyword] = {\r\n            text,\r\n            language: languageTag,\r\n            translatedKeyword,\r\n            compressed: compressionFlag === 1,\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      // 解析に失敗した場合は生データを16進数で保存\r\n      result[\"_raw_data\"] = this.bytesToHex(data)\r\n    }\r\n\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * tIMEチャンク（タイムスタンプ）を解析\r\n   * PNG作成時刻の情報を抽出\r\n   * @param data - tIMEチャンクのデータ部分（7バイト固定）\r\n   * @returns タイムスタンプオブジェクト、または解析失敗時はnull\r\n   */\r\n  parseTime(data: Uint8Array): PNGTimestamp | null {\r\n    // tIMEチャンクは必ず7バイト\r\n    if (data.length !== 7) return null\r\n\r\n    // バイナリデータから日時情報を抽出\r\n    const year = this.bytesToUint16(data, 0) // 年（2バイト）\r\n    const month = data[2] // 月（1バイト、1-12）\r\n    const day = data[3] // 日（1バイト、1-31）\r\n    const hour = data[4] // 時（1バイト、0-23）\r\n    const minute = data[5] // 分（1バイト、0-59）\r\n    const second = data[6] // 秒（1バイト、0-60）\r\n\r\n    if (month == null || day == null || hour == null || minute == null || second == null) {\r\n      return null\r\n    }\r\n\r\n    return {\r\n      year,\r\n      month,\r\n      day,\r\n      hour,\r\n      minute,\r\n      second,\r\n      // 読みやすい形式の日時文字列も生成\r\n      datetime: `${year.toString().padStart(4, \"0\")}-${month.toString().padStart(2, \"0\")}-${day.toString().padStart(2, \"0\")} ${hour.toString().padStart(2, \"0\")}:${minute.toString().padStart(2, \"0\")}:${second.toString().padStart(2, \"0\")}`,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * PNGファイルの完全解析を実行\r\n   * ファイル全体を読み込み、全チャンクを解析してメタデータを抽出\r\n   * @param file - 解析対象のPNGファイル\r\n   * @returns 完全なメタデータオブジェクト\r\n   * @throws PNG形式でない場合やファイル破損時にエラー\r\n   */\r\n  async analyze(file: File): Promise<PNGMetadata> {\r\n    // PNGファイルシグネチャの検証\r\n    const signature = await this.readBytes(file, 0, 8)\r\n    const expectedSignature = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a])\r\n\r\n    // シグネチャが一致しない場合はエラー\r\n    for (let i = 0; i < 8; i++) {\r\n      if (signature[i] !== expectedSignature[i]) {\r\n        throw new Error(\"無効なPNGファイルシグネチャです\")\r\n      }\r\n    }\r\n\r\n    // メタデータオブジェクトを初期化\r\n    const metadata: PNGMetadata = {\r\n      fileName: file.name,\r\n      fileSize: file.size,\r\n      chunks: [], // チャンク情報の配列\r\n      imageInfo: null, // 画像基本情報\r\n      textMetadata: {}, // テキストメタデータ\r\n      timestamp: null, // タイムスタンプ\r\n      physicalDimensions: null, // 物理的寸法（未実装）\r\n      rawChunks: [], // 生チャンクデータ\r\n    }\r\n\r\n    let offset = 8 // PNGシグネチャをスキップ\r\n\r\n    // ファイル終端まで全チャンクを順次解析\r\n    while (offset < file.size) {\r\n      // チャンクヘッダー（8バイト）を読み取り\r\n      if (offset + 8 > file.size) break\r\n\r\n      const header = await this.readBytes(file, offset, 8)\r\n      const length = this.bytesToUint32(header, 0) // データ長（4バイト）\r\n      const type = this.bytesToString(header, 4, 8) // チャンクタイプ（4バイト）\r\n\r\n      // チャンクデータとCRCを読み取り\r\n      if (offset + 8 + length + 4 > file.size) break\r\n\r\n      const data = await this.readBytes(file, offset + 8, length)\r\n      const crcBytes = await this.readBytes(file, offset + 8 + length, 4)\r\n      const crc = this.bytesToUint32(crcBytes, 0)\r\n\r\n      // チャンク情報を保存（表示用）\r\n      const chunkInfo = {\r\n        type,\r\n        length,\r\n        crc: `0x${crc.toString(16).padStart(8, \"0\")}`,\r\n        dataPreview: this.bytesToHex(data.slice(0, Math.min(32, data.length))) + (data.length > 32 ? \"...\" : \"\"),\r\n      }\r\n      metadata.chunks.push(chunkInfo)\r\n\r\n      // 生チャンクデータを保存（詳細表示用）\r\n      metadata.rawChunks.push({\r\n        type,\r\n        length,\r\n        data: this.bytesToHex(data),\r\n        crc,\r\n      })\r\n\r\n      // 特定チャンクの詳細解析\r\n      if (type === \"IHDR\") {\r\n        // 画像ヘッダー情報を解析\r\n        metadata.imageInfo = this.parseIHDR(data)\r\n      } else if ([\"tEXt\", \"zTXt\", \"iTXt\"].includes(type)) {\r\n        // テキストメタデータを解析\r\n        const textData = this.parseTextChunk(data, type)\r\n        Object.assign(metadata.textMetadata, textData)\r\n      } else if (type === \"tIME\") {\r\n        // タイムスタンプを解析\r\n        metadata.timestamp = this.parseTime(data)\r\n      } else if (type === \"IEND\") {\r\n        // 画像終端チャンクに到達したら解析終了\r\n        break\r\n      }\r\n\r\n      // 次のチャンクへ移動\r\n      offset += 8 + length + 4\r\n    }\r\n\r\n    return metadata\r\n  }\r\n}\r\n","import type { PNGMetadata, Position, Size } from \"./types\"\r\n\r\n/**\r\n * 画像プレビュー機能を管理するクラス\r\n * ズーム、パン、色解析、統計情報表示を提供\r\n */\r\nexport class ImagePreview {\r\n  private container: HTMLElement // プレビューコンテナ要素\r\n  private zoom = 1 // 現在のズーム倍率\r\n  private position: Position = { x: 0, y: 0 } // 画像の表示位置\r\n  private isDragging = false // ドラッグ中かどうか\r\n  private dragStart: Position = { x: 0, y: 0 } // ドラッグ開始位置\r\n  private imageElement: HTMLImageElement | null = null // 画像要素への参照\r\n  private naturalSize: Size = { width: 0, height: 0 } // 画像の元サイズ\r\n\r\n  constructor(container: HTMLElement) {\r\n    this.container = container\r\n  }\r\n\r\n  /**\r\n   * 画像プレビューをレンダリング\r\n   * 統計情報、コントロール、画像表示エリア、色解析を含む完全なUIを構築\r\n   * @param imageUrl - 表示する画像のURL（nullの場合は空状態を表示）\r\n   * @param metadata - 画像のメタデータ\r\n   */\r\n  render(imageUrl: string | null, metadata: PNGMetadata): void {\r\n    if (!imageUrl) {\r\n      // 画像がない場合の空状態を表示\r\n      this.container.innerHTML = `\r\n                <div class=\"empty-state\">\r\n                    <i class=\"fas fa-eye empty-icon\"></i>\r\n                    <p>PNGファイルをアップロードしてプレビューを表示</p>\r\n                </div>\r\n            `\r\n      return\r\n    }\r\n\r\n    // 完全なプレビューUIを構築\r\n    this.container.innerHTML = `\r\n            <!-- 画像統計情報カード -->\r\n            <div class=\"preview-stats\">\r\n                <div class=\"preview-card\">\r\n                    <i class=\"fas fa-ruler preview-icon blue\"></i>\r\n                    <div class=\"preview-content\">\r\n                        <p class=\"preview-label\">元サイズ</p>\r\n                        <p class=\"preview-value\" id=\"naturalSize\">読み込み中...</p>\r\n                    </div>\r\n                </div>\r\n                <div class=\"preview-card\">\r\n                    <i class=\"fas fa-info preview-icon green\"></i>\r\n                    <div class=\"preview-content\">\r\n                        <p class=\"preview-label\">アスペクト比</p>\r\n                        <p class=\"preview-value\" id=\"aspectRatio\">読み込み中...</p>\r\n                    </div>\r\n                </div>\r\n                <div class=\"preview-card\">\r\n                    <i class=\"fas fa-palette preview-icon purple\"></i>\r\n                    <div class=\"card-content\">\r\n                        <p class=\"preview-label\">ビット深度</p>\r\n                        <p class=\"preview-value\">${metadata?.imageInfo?.bitDepth || \"N/A\"} ビット</p>\r\n                    </div>\r\n                </div>\r\n                <div class=\"preview-card\">\r\n                    <i class=\"fas fa-download preview-icon orange\"></i>\r\n                    <div class=\"card-content\">\r\n                        <p class=\"preview-label\">ファイルサイズ</p>\r\n                        <p class=\"preview-value\">${this.formatFileSize(metadata?.fileSize || 0)}</p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n\r\n            <!-- 画像表示コンテナ -->\r\n            <div class=\"image-container\">\r\n                <div class=\"image-header\">\r\n                    <div class=\"image-title\">\r\n                        <i class=\"fas fa-eye\"></i>\r\n                        <span>画像プレビュー</span>\r\n                        <span class=\"zoom-badge\" id=\"zoomBadge\">ズーム: 100%</span>\r\n                    </div>\r\n                    <!-- 画像操作コントロール -->\r\n                    <div class=\"image-controls\">\r\n                        <button class=\"control-button\" id=\"zoomOut\" title=\"縮小\">\r\n                            <i class=\"fas fa-search-minus\"></i>\r\n                        </button>\r\n                        <button class=\"control-button\" id=\"zoomIn\" title=\"拡大\">\r\n                            <i class=\"fas fa-search-plus\"></i>\r\n                        </button>\r\n                        <button class=\"control-button\" id=\"resetZoom\" title=\"リセット\">\r\n                            <i class=\"fas fa-undo\"></i>\r\n                        </button>\r\n                        <button class=\"control-button\" id=\"downloadImage\" title=\"ダウンロード\">\r\n                            <i class=\"fas fa-download\"></i>\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n                <!-- 画像表示ビューポート -->\r\n                <div class=\"image-viewport\" id=\"imageViewport\">\r\n                    <img class=\"preview-image\" id=\"previewImage\" src=\"${imageUrl}\" alt=\"PNG プレビュー\">\r\n                    <div class=\"zoom-info\" id=\"zoomInfo\" style=\"display: none;\">100% ズーム</div>\r\n                </div>\r\n            </div>\r\n\r\n            <!-- 色解析セクション（画像読み込み後に表示） -->\r\n            <div class=\"color-analysis\" id=\"colorAnalysis\" style=\"display: none;\">\r\n                <h3>色解析</h3>\r\n                <div class=\"color-section\">\r\n                    <h4>平均色</h4>\r\n                    <div class=\"average-color\" id=\"averageColor\">\r\n                        <div class=\"spinner\"></div>\r\n                        <span>色を解析中...</span>\r\n                    </div>\r\n                </div>\r\n                <div class=\"color-section\">\r\n                    <h4>主要色</h4>\r\n                    <div class=\"dominant-colors\" id=\"dominantColors\"></div>\r\n                </div>\r\n            </div>\r\n        `\r\n\r\n    // イベントリスナーを設定\r\n    this.setupEventListeners(imageUrl, metadata)\r\n  }\r\n\r\n  /**\r\n   * 画像プレビューのイベントリスナーを設定\r\n   * 画像読み込み、ズーム操作、ドラッグ操作、ダウンロードなど\r\n   * @param imageUrl - 画像URL\r\n   * @param metadata - 画像メタデータ\r\n   */\r\n  private setupEventListeners(imageUrl: string, metadata: PNGMetadata): void {\r\n    // DOM要素を取得\r\n    const image = document.getElementById(\"previewImage\") as HTMLImageElement\r\n    const viewport = document.getElementById(\"imageViewport\") as HTMLElement\r\n    const zoomBadge = document.getElementById(\"zoomBadge\") as HTMLElement\r\n    const zoomInfo = document.getElementById(\"zoomInfo\") as HTMLElement\r\n\r\n    // 画像読み込み完了イベント\r\n    image.onload = () => {\r\n      this.imageElement = image\r\n      this.naturalSize = {\r\n        width: image.naturalWidth,\r\n        height: image.naturalHeight,\r\n      }\r\n\r\n      // サイズ情報を更新\r\n      const naturalSizeEl = document.getElementById(\"naturalSize\")\r\n      const aspectRatioEl = document.getElementById(\"aspectRatio\")\r\n      if (naturalSizeEl) naturalSizeEl.textContent = `${this.naturalSize.width} × ${this.naturalSize.height}`\r\n      if (aspectRatioEl) aspectRatioEl.textContent = this.calculateAspectRatio()\r\n\r\n      // 色解析セクションを表示して解析開始\r\n      const colorAnalysisEl = document.getElementById(\"colorAnalysis\")\r\n      if (colorAnalysisEl) colorAnalysisEl.style.display = \"block\"\r\n      this.analyzeColors()\r\n    }\r\n\r\n    // ズームコントロールボタンの設定\r\n    const zoomInBtn = document.getElementById(\"zoomIn\")\r\n    const zoomOutBtn = document.getElementById(\"zoomOut\")\r\n    const resetZoomBtn = document.getElementById(\"resetZoom\")\r\n    const downloadBtn = document.getElementById(\"downloadImage\")\r\n\r\n    // 拡大ボタン\r\n    if (zoomInBtn) {\r\n      zoomInBtn.onclick = () => {\r\n        this.zoom = Math.min(this.zoom * 1.5, 10) // 最大10倍まで\r\n        this.updateImageTransform()\r\n        this.updateZoomDisplay()\r\n      }\r\n    }\r\n\r\n    // 縮小ボタン\r\n    if (zoomOutBtn) {\r\n      zoomOutBtn.onclick = () => {\r\n        this.zoom = Math.max(this.zoom / 1.5, 0.1) // 最小0.1倍まで\r\n        this.updateImageTransform()\r\n        this.updateZoomDisplay()\r\n      }\r\n    }\r\n\r\n    // リセットボタン\r\n    if (resetZoomBtn) {\r\n      resetZoomBtn.onclick = () => {\r\n        this.zoom = 1 // ズームを100%に\r\n        this.position = { x: 0, y: 0 } // 位置をリセット\r\n        this.updateImageTransform()\r\n        this.updateZoomDisplay()\r\n      }\r\n    }\r\n\r\n    // ダウンロードボタン\r\n    if (downloadBtn) {\r\n      downloadBtn.onclick = () => {\r\n        const link = document.createElement(\"a\")\r\n        link.href = imageUrl\r\n        link.download = metadata.fileName\r\n        link.click()\r\n      }\r\n    }\r\n\r\n    // ドラッグ機能の設定（ズーム時のみ有効）\r\n    viewport.onmousedown = (e: MouseEvent) => {\r\n      if (this.zoom > 1) {\r\n        this.isDragging = true\r\n        this.dragStart = {\r\n          x: e.clientX - this.position.x,\r\n          y: e.clientY - this.position.y,\r\n        }\r\n        viewport.style.cursor = \"grabbing\" // ドラッグ中のカーソル\r\n      }\r\n    }\r\n\r\n    // マウス移動（ドラッグ中の画像移動）\r\n    viewport.onmousemove = (e: MouseEvent) => {\r\n      if (this.isDragging && this.zoom > 1) {\r\n        this.position = {\r\n          x: e.clientX - this.dragStart.x,\r\n          y: e.clientY - this.dragStart.y,\r\n        }\r\n        this.updateImageTransform()\r\n      }\r\n    }\r\n\r\n    // マウスアップ（ドラッグ終了）\r\n    viewport.onmouseup = () => {\r\n      this.isDragging = false\r\n      viewport.style.cursor = this.zoom > 1 ? \"grab\" : \"default\"\r\n    }\r\n\r\n    // マウスがビューポートから離れた時（ドラッグ終了）\r\n    viewport.onmouseleave = () => {\r\n      this.isDragging = false\r\n      viewport.style.cursor = this.zoom > 1 ? \"grab\" : \"default\"\r\n    }\r\n\r\n    // 初期表示を更新\r\n    this.updateZoomDisplay()\r\n  }\r\n\r\n  /**\r\n   * 画像の変形（ズーム・パン）を適用\r\n   * CSS transformを使用して画像の表示を更新\r\n   */\r\n  private updateImageTransform(): void {\r\n    if (this.imageElement) {\r\n      const transform = `scale(${this.zoom}) translate(${this.position.x / this.zoom}px, ${this.position.y / this.zoom}px)`\r\n      this.imageElement.style.transform = transform\r\n    }\r\n  }\r\n\r\n  /**\r\n   * ズーム表示の更新\r\n   * ズーム率の表示、ボタンの有効/無効状態、カーソルの変更\r\n   */\r\n  private updateZoomDisplay(): void {\r\n    const zoomBadge = document.getElementById(\"zoomBadge\")\r\n    const zoomInfo = document.getElementById(\"zoomInfo\")\r\n    const viewport = document.getElementById(\"imageViewport\")\r\n\r\n    const zoomPercent = Math.round(this.zoom * 100)\r\n\r\n    // ズーム率バッジの更新\r\n    if (zoomBadge) zoomBadge.textContent = `ズーム: ${zoomPercent}%`\r\n\r\n    // ズーム情報の表示/非表示\r\n    if (zoomInfo) {\r\n      if (this.zoom !== 1) {\r\n        zoomInfo.textContent = `${zoomPercent}% ズーム`\r\n        zoomInfo.style.display = \"block\"\r\n      } else {\r\n        zoomInfo.style.display = \"none\"\r\n      }\r\n    }\r\n\r\n    // カーソルの変更（ズーム時はドラッグ可能を示す）\r\n    if (viewport) {\r\n      viewport.style.cursor = this.zoom > 1 ? \"grab\" : \"default\"\r\n    }\r\n\r\n    // ボタンの有効/無効状態を更新\r\n    const zoomOutBtn = document.getElementById(\"zoomOut\") as HTMLButtonElement\r\n    const zoomInBtn = document.getElementById(\"zoomIn\") as HTMLButtonElement\r\n    if (zoomOutBtn) zoomOutBtn.disabled = this.zoom <= 0.1 // 最小ズーム時は縮小無効\r\n    if (zoomInBtn) zoomInBtn.disabled = this.zoom >= 10 // 最大ズーム時は拡大無効\r\n  }\r\n\r\n  /**\r\n   * アスペクト比を計算\r\n   * 最大公約数を使用して簡約形で表示（例: 16:9）\r\n   * @returns アスペクト比の文字列\r\n   */\r\n  private calculateAspectRatio(): string {\r\n    if (!this.naturalSize.width || !this.naturalSize.height) return \"N/A\"\r\n\r\n    // 最大公約数を求める関数（ユークリッドの互除法）\r\n    const gcd = (a: number, b: number): number => (b === 0 ? a : gcd(b, a % b))\r\n    const divisor = gcd(this.naturalSize.width, this.naturalSize.height)\r\n    return `${this.naturalSize.width / divisor}:${this.naturalSize.height / divisor}`\r\n  }\r\n\r\n  /**\r\n   * ファイルサイズを人間が読みやすい形式にフォーマット\r\n   * @param bytes - バイト数\r\n   * @returns フォーマットされたサイズ文字列\r\n   */\r\n  private formatFileSize(bytes: number): string {\r\n    if (bytes < 1024) return `${bytes} B`\r\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`\r\n    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`\r\n  }\r\n\r\n  /**\r\n   * 画像の色解析を実行\r\n   * Canvas APIを使用して平均色と主要色を抽出\r\n   */\r\n  private analyzeColors(): void {\r\n    if (!this.imageElement) return\r\n\r\n    // 解析用のCanvasを作成\r\n    const canvas = document.createElement(\"canvas\")\r\n    const ctx = canvas.getContext(\"2d\")\r\n    if (!ctx) return\r\n\r\n    // パフォーマンスのため、解析サイズを制限\r\n    canvas.width = Math.min(this.imageElement.naturalWidth, 200)\r\n    canvas.height = Math.min(this.imageElement.naturalHeight, 200)\r\n\r\n    try {\r\n      // 画像をCanvasに描画\r\n      ctx.drawImage(this.imageElement, 0, 0, canvas.width, canvas.height)\r\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)\r\n      const data = imageData.data\r\n\r\n      // 色の出現回数をカウントするマップ\r\n      const colorMap = new Map<string, number>()\r\n      let totalR = 0,\r\n        totalG = 0,\r\n        totalB = 0 // 平均色計算用\r\n      const pixelCount = data.length / 4\r\n\r\n      // 全ピクセルを走査\r\n      for (let i = 0; i < data.length; i += 4) {\r\n        if (i + 3 >= data.length) break\r\n\r\n        const r = data[i] ?? 0 // 赤成分\r\n        const g = data[i + 1] ?? 0 // 緑成分\r\n        const b = data[i + 2] ?? 0 // 青成分\r\n        const a = data[i + 3] ?? 0 // アルファ成分\r\n\r\n        // 透明でないピクセルのみ処理\r\n        if (a > 128) {\r\n          // 平均色計算用に累積\r\n          totalR += r\r\n          totalG += g\r\n          totalB += b\r\n\r\n          // 主要色抽出のため色をグループ化（32段階に量子化）\r\n          const groupedR = Math.floor(r / 32) * 32\r\n          const groupedG = Math.floor(g / 32) * 32\r\n          const groupedB = Math.floor(b / 32) * 32\r\n          const colorKey = `rgb(${groupedR},${groupedG},${groupedB})`\r\n\r\n          // 色の出現回数をカウント\r\n          colorMap.set(colorKey, (colorMap.get(colorKey) || 0) + 1)\r\n        }\r\n      }\r\n\r\n      // 平均色を計算\r\n      const averageColor = `rgb(${Math.round(totalR / pixelCount)}, ${Math.round(totalG / pixelCount)}, ${Math.round(totalB / pixelCount)})`\r\n\r\n      // 主要色を抽出（出現回数順にソートして上位8色）\r\n      const dominantColors = Array.from(colorMap.entries())\r\n        .sort((a, b) => b[1] - a[1]) // 出現回数の降順でソート\r\n        .slice(0, 8) // 上位8色を取得\r\n        .map(([color]) => color)\r\n\r\n      // 結果を表示\r\n      this.displayColorAnalysis(averageColor, dominantColors, Math.round(pixelCount))\r\n    } catch (error) {\r\n      console.error(\"色解析に失敗しました:\", error)\r\n      const avgColorEl = document.getElementById(\"averageColor\")\r\n      if (avgColorEl) {\r\n        avgColorEl.innerHTML = '<span style=\"color: #dc2626;\">色解析に失敗しました</span>'\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 色解析結果をUIに表示\r\n   * @param averageColor - 平均色のCSS色値\r\n   * @param dominantColors - 主要色の配列\r\n   * @param pixelCount - 解析したピクセル数\r\n   */\r\n  private displayColorAnalysis(averageColor: string, dominantColors: string[], pixelCount: number): void {\r\n    // 平均色の表示\r\n    const avgColorEl = document.getElementById(\"averageColor\")\r\n    if (avgColorEl) {\r\n      avgColorEl.innerHTML = `\r\n            <div class=\"color-swatch\" style=\"background-color: ${averageColor};\"></div>\r\n            <div class=\"color-info\">\r\n                <div class=\"color-value\">${averageColor}</div>\r\n                <div class=\"color-description\">${pixelCount.toLocaleString()} ピクセルから計算</div>\r\n            </div>\r\n        `\r\n    }\r\n\r\n    // 主要色の表示\r\n    const dominantContainer = document.getElementById(\"dominantColors\")\r\n    if (dominantContainer) {\r\n      dominantContainer.innerHTML = dominantColors\r\n        .map((color) => {\r\n          const rgb = color.match(/\\d+/g)\r\n          let rgbValues = \"N/A\"\r\n\r\n          if (rgb && rgb.length >= 3) {\r\n            const r = rgb.at(0) ?? \"0\"\r\n            const g = rgb.at(1) ?? \"0\"\r\n            const b = rgb.at(2) ?? \"0\"\r\n            rgbValues = `${r},${g},${b}`\r\n          }\r\n\r\n          return `\r\n                <div class=\"dominant-color\">\r\n                    <div class=\"dominant-swatch\" style=\"background-color: ${color};\" title=\"${color}\"></div>\r\n                    <div class=\"dominant-value\">${rgbValues}</div>\r\n                </div>\r\n            `\r\n        })\r\n        .join(\"\")\r\n    }\r\n  }\r\n}\r\n","import \"./styles.scss\"\r\nimport { PNGAnalyzer } from \"./png-analyzer\"\r\nimport { ImagePreview } from \"./image-preview\"\r\nimport type { PNGMetadata, JSNViewOptions } from \"./types\"\r\n\r\n// CDN経由で読み込まれるjsnviewをグローバル関数として宣言\r\ndeclare global {\r\n  function jsnview(data: any, options?: JSNViewOptions): HTMLElement\r\n}\r\n\r\n/**\r\n * PNGメタデータ抽出ツールのメインクラス\r\n * ファイルのアップロード、解析、表示を統合管理する\r\n */\r\nclass PNGMetadataExtractor {\r\n  private analyzer: PNGAnalyzer // PNG解析エンジン\r\n  private imagePreview: ImagePreview // 画像プレビュー管理\r\n  private currentMetadata: PNGMetadata | null = null // 現在解析中のメタデータ\r\n  private currentImageUrl: string | null = null // 現在表示中の画像URL\r\n\r\n  constructor() {\r\n    // PNG解析エンジンを初期化\r\n    this.analyzer = new PNGAnalyzer()\r\n\r\n    // 画像プレビューコンテナを取得して初期化\r\n    const previewContainer = document.getElementById(\"imagePreview\")\r\n    if (!previewContainer) {\r\n      throw new Error(\"画像プレビューコンテナが見つかりません\")\r\n    }\r\n    this.imagePreview = new ImagePreview(previewContainer)\r\n\r\n    // イベントリスナーを設定\r\n    this.initializeEventListeners()\r\n  }\r\n\r\n  /**\r\n   * 全てのイベントリスナーを初期化\r\n   * ファイルアップロード、ドラッグ&ドロップ、タブ切り替えなど\r\n   */\r\n  private initializeEventListeners(): void {\r\n    // 必要なDOM要素を取得\r\n    const uploadArea = document.getElementById(\"uploadArea\")\r\n    const uploadButton = document.getElementById(\"uploadButton\")\r\n    const fileInput = document.getElementById(\"fileInput\") as HTMLInputElement\r\n    const exportButton = document.getElementById(\"exportButton\")\r\n\r\n    // 必須要素の存在確認\r\n    if (!uploadArea || !uploadButton || !fileInput || !exportButton) {\r\n      throw new Error(\"必要なDOM要素が見つかりません\")\r\n    }\r\n\r\n    // ファイル選択イベント（input要素）\r\n    fileInput.addEventListener(\"change\", (e: Event) => {\r\n      const target = e.target as HTMLInputElement\r\n      if (target.files && target.files.length > 0 && target.files[0]) {\r\n        this.handleFile(target.files[0])\r\n      }\r\n    })\r\n\r\n    // アップロードボタンクリック（ファイル選択ダイアログを開く）\r\n    uploadButton.addEventListener(\"click\", () => {\r\n      fileInput.click()\r\n    })\r\n\r\n    // アップロードエリアクリック（ファイル選択ダイアログを開く）\r\n    uploadArea.addEventListener(\"click\", () => {\r\n      fileInput.click()\r\n    })\r\n\r\n    // ドラッグオーバー時の視覚的フィードバック\r\n    uploadArea.addEventListener(\"dragover\", (e: DragEvent) => {\r\n      e.preventDefault() // デフォルトの動作を無効化\r\n      uploadArea.classList.add(\"drag-over\") // ドラッグ中のスタイルを適用\r\n    })\r\n\r\n    // ドラッグが離れた時の視覚的フィードバック解除\r\n    uploadArea.addEventListener(\"dragleave\", () => {\r\n      uploadArea.classList.remove(\"drag-over\")\r\n    })\r\n\r\n    // ファイルドロップ処理\r\n    uploadArea.addEventListener(\"drop\", (e: DragEvent) => {\r\n      e.preventDefault() // デフォルトの動作を無効化\r\n      uploadArea.classList.remove(\"drag-over\") // ドラッグスタイルを解除\r\n\r\n      // ドロップされたファイルを処理\r\n      if (e.dataTransfer?.files && e.dataTransfer.files.length > 0 && e.dataTransfer.files[0]) {\r\n        this.handleFile(e.dataTransfer.files[0])\r\n      }\r\n    })\r\n\r\n    // エクスポートボタン（JSON形式でメタデータをダウンロード）\r\n    exportButton.addEventListener(\"click\", () => {\r\n      this.exportResults()\r\n    })\r\n\r\n    // タブ切り替えイベント\r\n    document.querySelectorAll(\".tab-button\").forEach((button) => {\r\n      button.addEventListener(\"click\", () => {\r\n        const tabButton = button as HTMLElement\r\n        const tabName = tabButton.dataset.tab\r\n        if (tabName) {\r\n          this.switchTab(tabName)\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * ファイル処理のメイン関数\r\n   * PNG形式の検証、解析、結果表示を行う\r\n   * @param file - 処理対象のファイル\r\n   */\r\n  private async handleFile(file: File): Promise<void> {\r\n    // PNG形式の検証\r\n    if (!file.type.includes(\"png\")) {\r\n      this.showError(\"PNGファイルを選択してください\")\r\n      return\r\n    }\r\n\r\n    // ローディング表示開始\r\n    this.showLoading(true)\r\n    this.hideError()\r\n\r\n    // 前回の画像URLをクリーンアップ（メモリリーク防止）\r\n    if (this.currentImageUrl) {\r\n      URL.revokeObjectURL(this.currentImageUrl)\r\n    }\r\n\r\n    try {\r\n      // PNG解析を実行\r\n      const metadata = await this.analyzer.analyze(file)\r\n      this.currentMetadata = metadata\r\n\r\n      // 画像表示用のURLを作成\r\n      this.currentImageUrl = URL.createObjectURL(file)\r\n\r\n      // 解析結果を表示\r\n      this.displayResults(metadata)\r\n      this.showLoading(false)\r\n\r\n      // プレビュータブに自動切り替え\r\n      this.switchTab(\"preview\")\r\n    } catch (error) {\r\n      // エラーハンドリング\r\n      const errorMessage = error instanceof Error ? error.message : \"PNGファイルの解析に失敗しました\"\r\n      this.showError(errorMessage)\r\n      this.showLoading(false)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 解析結果をUIに表示\r\n   * サマリーカード、各タブコンテンツ、画像プレビューを更新\r\n   * @param metadata - 表示するメタデータ\r\n   */\r\n  private displayResults(metadata: PNGMetadata): void {\r\n    // 結果セクションを表示\r\n    const resultsEl = document.getElementById(\"results\")\r\n    if (resultsEl) resultsEl.style.display = \"block\"\r\n\r\n    // サマリーカードの更新\r\n    const fileSizeEl = document.getElementById(\"fileSize\")\r\n    const dimensionsEl = document.getElementById(\"dimensions\")\r\n    const colorTypeEl = document.getElementById(\"colorType\")\r\n    const chunkCountEl = document.getElementById(\"chunkCount\")\r\n\r\n    if (fileSizeEl) fileSizeEl.textContent = `${(metadata.fileSize / 1024).toFixed(1)} KB`\r\n    if (dimensionsEl)\r\n      dimensionsEl.textContent = `${metadata.imageInfo?.width || 0} × ${metadata.imageInfo?.height || 0}`\r\n    if (colorTypeEl) colorTypeEl.textContent = metadata.imageInfo?.colorType || \"不明\"\r\n    if (chunkCountEl) chunkCountEl.textContent = metadata.chunks.length.toString()\r\n\r\n    // 各タブコンテンツの更新\r\n    this.updateImageInfo(metadata.imageInfo)\r\n    this.updateChunks(metadata.chunks)\r\n    this.updateMetadata(metadata.textMetadata)\r\n    this.updateTimestamp(metadata.timestamp)\r\n    this.updateRawData(metadata.rawChunks)\r\n    this.displayJSONTree(metadata, document.getElementById(\"fullJsonContainer\"))\r\n\r\n    // 画像プレビューの更新\r\n    if (this.currentImageUrl) {\r\n      this.imagePreview.render(this.currentImageUrl, metadata)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 画像情報タブの内容を更新\r\n   * @param imageInfo - 画像の基本情報\r\n   */\r\n  private updateImageInfo(imageInfo: PNGMetadata[\"imageInfo\"]): void {\r\n    const container = document.getElementById(\"imageInfoGrid\")\r\n    if (!container) return\r\n\r\n    if (!imageInfo) {\r\n      container.innerHTML = \"<p>画像情報が利用できません</p>\"\r\n      return\r\n    }\r\n\r\n    // 画像情報をグリッド形式で表示\r\n    container.innerHTML = Object.entries(imageInfo)\r\n      .map(\r\n        ([key, value]) => `\r\n                <div class=\"info-item\">\r\n                    <span class=\"info-label\">${this.translateImageInfoKey(key)}</span>\r\n                    <span class=\"info-value\">${value}</span>\r\n                </div>\r\n            `,\r\n      )\r\n      .join(\"\")\r\n  }\r\n\r\n  /**\r\n   * 画像情報のキーを日本語に翻訳\r\n   * @param key - 英語のキー名\r\n   * @returns 日本語のキー名\r\n   */\r\n  private translateImageInfoKey(key: string): string {\r\n    const translations: { [key: string]: string } = {\r\n      width: \"幅\",\r\n      height: \"高さ\",\r\n      bitDepth: \"ビット深度\",\r\n      colorType: \"色タイプ\",\r\n      compressionMethod: \"圧縮方式\",\r\n      filterMethod: \"フィルター方式\",\r\n      interlaceMethod: \"インターレース方式\",\r\n    }\r\n    return translations[key] || key\r\n  }\r\n\r\n  /**\r\n   * チャンク情報タブの内容を更新\r\n   * @param chunks - PNGチャンクの配列\r\n   */\r\n  private updateChunks(chunks: PNGMetadata[\"chunks\"]): void {\r\n    const container = document.getElementById(\"chunksContainer\")\r\n    if (!container) return\r\n\r\n    container.innerHTML = chunks\r\n      .map(\r\n        (chunk) => `\r\n            <div class=\"chunk-item\">\r\n                <div class=\"chunk-header\">\r\n                    <div style=\"display: flex; align-items: center; gap: 0.5rem;\">\r\n                        <span class=\"chunk-type\">${chunk.type}</span>\r\n                        <span class=\"chunk-info\">長さ: ${chunk.length} バイト</span>\r\n                    </div>\r\n                    <span class=\"chunk-crc\">CRC: ${chunk.crc}</span>\r\n                </div>\r\n                <div class=\"chunk-data\">${chunk.dataPreview}</div>\r\n            </div>\r\n        `,\r\n      )\r\n      .join(\"\")\r\n  }\r\n\r\n  /**\r\n   * テキストメタデータタブの内容を更新\r\n   * @param textMetadata - テキスト形式のメタデータ\r\n   */\r\n  private updateMetadata(textMetadata: PNGMetadata[\"textMetadata\"]): void {\r\n    const container = document.getElementById(\"metadataContainer\")\r\n    if (!container) return\r\n\r\n    if (Object.keys(textMetadata).length === 0) {\r\n      container.innerHTML = `\r\n                <div class=\"empty-state\">\r\n                    <i class=\"fas fa-info-circle empty-icon\"></i>\r\n                    <p>このPNGファイルにはテキストメタデータが見つかりませんでした</p>\r\n                </div>\r\n            `\r\n      return\r\n    }\r\n\r\n    container.innerHTML = Object.entries(textMetadata)\r\n      .map(\r\n        ([key, value]) => `\r\n                <div class=\"chunk-item\">\r\n                    <h4 style=\"margin-bottom: 0.5rem; font-weight: 600;\">${key}</h4>\r\n                    <div style=\"background-color: #f9fafb; padding: 0.75rem; border-radius: 0.375rem; font-size: 0.875rem; color: #6b7280; word-break: break-all;\">\r\n                        ${\r\n                          typeof value === \"object\"\r\n                            ? `<pre style=\"white-space: pre-wrap; margin: 0;\">${JSON.stringify(value, null, 2)}</pre>`\r\n                            : `<span>${value}</span>`\r\n                        }\r\n                    </div>\r\n                </div>\r\n            `,\r\n      )\r\n      .join(\"\")\r\n  }\r\n\r\n  /**\r\n   * タイムスタンプタブの内容を更新\r\n   * @param timestamp - PNG作成時刻情報\r\n   */\r\n  private updateTimestamp(timestamp: PNGMetadata[\"timestamp\"]): void {\r\n    const container = document.getElementById(\"timestampContainer\")\r\n    if (!container) return\r\n\r\n    if (!timestamp) {\r\n      container.innerHTML = `\r\n                <div class=\"empty-state\">\r\n                    <i class=\"fas fa-clock empty-icon\"></i>\r\n                    <p>タイムスタンプ情報が見つかりませんでした</p>\r\n                </div>\r\n            `\r\n      return\r\n    }\r\n\r\n    // タイムスタンプ情報をグリッド形式で表示\r\n    container.innerHTML = `\r\n            <div class=\"chunk-item\">\r\n                <div style=\"display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;\">\r\n                    <i class=\"fas fa-clock\" style=\"color: #3b82f6;\"></i>\r\n                    <h4 style=\"margin: 0; font-weight: 600;\">作成時刻</h4>\r\n                </div>\r\n                <div style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem;\">\r\n                    ${Object.entries(timestamp)\r\n                      .filter(([key]) => key !== \"datetime\") // datetime は除外\r\n                      .map(\r\n                        ([key, value]) => `\r\n                        <div style=\"text-align: center; padding: 0.75rem; background-color: #f9fafb; border-radius: 0.375rem;\">\r\n                            <div style=\"font-size: 0.875rem; color: #6b7280; text-transform: capitalize; margin-bottom: 0.25rem;\">${this.translateTimestampKey(key)}</div>\r\n                            <div style=\"font-weight: bold;\">${value}</div>\r\n                        </div>\r\n                    `,\r\n                      )\r\n                      .join(\"\")}\r\n                </div>\r\n                <div style=\"margin-top: 1rem; text-align: center; font-size: 1.1rem; font-weight: 600; color: #374151;\">\r\n                    ${timestamp.datetime}\r\n                </div>\r\n            </div>\r\n        `\r\n  }\r\n\r\n  /**\r\n   * タイムスタンプのキーを日本語に翻訳\r\n   * @param key - 英語のキー名\r\n   * @returns 日本語のキー名\r\n   */\r\n  private translateTimestampKey(key: string): string {\r\n    const translations: { [key: string]: string } = {\r\n      year: \"年\",\r\n      month: \"月\",\r\n      day: \"日\",\r\n      hour: \"時\",\r\n      minute: \"分\",\r\n      second: \"秒\",\r\n    }\r\n    return translations[key] || key\r\n  }\r\n\r\n  /**\r\n   * 生データタブの内容を更新\r\n   * @param rawChunks - 生のチャンクデータ\r\n   */\r\n  private updateRawData(rawChunks: PNGMetadata[\"rawChunks\"]): void {\r\n    const container = document.getElementById(\"rawDataContainer\")\r\n    if (!container) return\r\n\r\n    container.innerHTML = rawChunks\r\n      .map(\r\n        (chunk) => `\r\n            <div class=\"chunk-item\">\r\n                <div style=\"padding: 1rem; border-bottom: 1px solid #e5e7eb; background-color: #f9fafb; display: flex; justify-content: space-between; align-items: center;\">\r\n                    <span class=\"chunk-type\">${chunk.type}</span>\r\n                    <span style=\"font-size: 0.875rem; color: #6b7280;\">\r\n                        ${chunk.length} バイト | CRC: 0x${chunk.crc.toString(16).padStart(8, \"0\")}\r\n                    </span>\r\n                </div>\r\n                <div style=\"padding: 1rem;\">\r\n                    <div style=\"font-family: monospace; font-size: 0.75rem; background-color: #f3f4f6; padding: 0.75rem; border-radius: 0.375rem; max-height: 8rem; overflow-y: auto; word-break: break-all;\">\r\n                        ${chunk.data.match(/.{1,64}/g)?.join(\"\\n\") || chunk.data}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        `,\r\n      )\r\n      .join(\"\")\r\n  }\r\n\r\n  /**\r\n   * JSONツリービューを表示する\r\n   * @param metadata - 表示するメタデータ\r\n   * @param parentElement - 表示先の要素\r\n   * @param options - 表示オプション\r\n   */\r\n  private displayJSONTree(\r\n    metadata: PNGMetadata,\r\n    parentElement: HTMLElement | null,\r\n    options: JSNViewOptions = {},\r\n  ): void {\r\n    // JSONビューのデフォルト設定\r\n    const DEFAULT_JSON_VIEW_OPTIONS: JSNViewOptions = {\r\n      showLen: false, // 配列の長さを表示しない\r\n      showType: false, // データ型を表示しない\r\n      showBrackets: true, // 括弧を表示\r\n      showFoldmarker: false, // 折りたたみマーカーを表示しない\r\n      colors: {\r\n        boolean: \"#ff2929\", // 真偽値の色\r\n        null: \"#ff2929\", // null値の色\r\n        string: \"#690\", // 文字列の色\r\n        number: \"#905\", // 数値の色\r\n        float: \"#002f99\", // 浮動小数点数の色\r\n      },\r\n    }\r\n\r\n    if (!parentElement) return\r\n\r\n    // コンテナをリセット\r\n    parentElement.innerHTML = \"\"\r\n    parentElement.className = \"\"\r\n\r\n    // メタデータの有効性チェック\r\n    if (!metadata || typeof metadata !== \"object\" || Object.keys(metadata).length === 0) {\r\n      parentElement.className = \"text-center text-secondary\"\r\n      parentElement.innerHTML = \"データがありません\"\r\n      return\r\n    }\r\n\r\n    // オプションをマージ\r\n    const mergedOptions: JSNViewOptions = {\r\n      ...DEFAULT_JSON_VIEW_OPTIONS,\r\n      ...options,\r\n      colors: {\r\n        ...DEFAULT_JSON_VIEW_OPTIONS.colors,\r\n        ...(options.colors || {}),\r\n      },\r\n    }\r\n\r\n    // JSONツリービューを生成して表示\r\n    const treeView = jsnview(metadata, mergedOptions)\r\n    parentElement.appendChild(treeView)\r\n  }\r\n\r\n  /**\r\n   * タブを切り替える\r\n   * @param tabName - 切り替え先のタブ名\r\n   */\r\n  private switchTab(tabName: string): void {\r\n    // タブボタンの状態を更新\r\n    document.querySelectorAll(\".tab-button\").forEach((button) => {\r\n      button.classList.remove(\"active\")\r\n    })\r\n    const activeTab = document.querySelector(`[data-tab=\"${tabName}\"]`)\r\n    if (activeTab) activeTab.classList.add(\"active\")\r\n\r\n    // タブコンテンツの表示を更新\r\n    document.querySelectorAll(\".tab-content\").forEach((content) => {\r\n      content.classList.remove(\"active\")\r\n    })\r\n    const activeContent = document.getElementById(`tab-${tabName}`)\r\n    if (activeContent) activeContent.classList.add(\"active\")\r\n  }\r\n\r\n  /**\r\n   * 解析結果をJSONファイルとしてエクスポート\r\n   */\r\n  private exportResults(): void {\r\n    if (!this.currentMetadata) return\r\n\r\n    // JSONデータを整形\r\n    const dataStr = JSON.stringify(this.currentMetadata, null, 2)\r\n    const dataBlob = new Blob([dataStr], { type: \"application/json\" })\r\n    const url = URL.createObjectURL(dataBlob)\r\n\r\n    // ダウンロードリンクを作成して実行\r\n    const link = document.createElement(\"a\")\r\n    link.href = url\r\n    link.download = `${this.currentMetadata.fileName}_metadata.json`\r\n    link.click()\r\n\r\n    // メモリリーク防止のためURLを解放\r\n    URL.revokeObjectURL(url)\r\n  }\r\n\r\n  /**\r\n   * ローディング表示の制御\r\n   * @param show - 表示するかどうか\r\n   */\r\n  private showLoading(show: boolean): void {\r\n    const loadingEl = document.getElementById(\"loading\")\r\n    if (loadingEl) loadingEl.style.display = show ? \"flex\" : \"none\"\r\n  }\r\n\r\n  /**\r\n   * エラーメッセージを表示\r\n   * @param message - 表示するエラーメッセージ\r\n   */\r\n  private showError(message: string): void {\r\n    const errorElement = document.getElementById(\"error\")\r\n    if (errorElement) {\r\n      errorElement.textContent = message\r\n      errorElement.style.display = \"block\"\r\n    }\r\n  }\r\n\r\n  /**\r\n   * エラーメッセージを非表示\r\n   */\r\n  private hideError(): void {\r\n    const errorElement = document.getElementById(\"error\")\r\n    if (errorElement) errorElement.style.display = \"none\"\r\n  }\r\n}\r\n\r\n/**\r\n * Service Workerを登録する\r\n * PWAとしてオフライン動作を可能にする\r\n */\r\nfunction registerServiceWorker(): void {\r\n  if (\"serviceWorker\" in navigator) {\r\n    window.addEventListener(\"load\", () => {\r\n      navigator.serviceWorker\r\n        .register(\"./sw.js\")\r\n        .then((registration) => {\r\n          console.log(\"[PWA] Service Worker 登録成功:\", registration.scope)\r\n        })\r\n        .catch((error) => {\r\n          console.error(\"[PWA] Service Worker 登録失敗:\", error)\r\n        })\r\n    })\r\n  }\r\n}\r\n\r\n// アプリケーションの初期化\r\n// DOMが完全に読み込まれた後にメインクラスをインスタンス化\r\ndocument.addEventListener(\"DOMContentLoaded\", () => {\r\n  new PNGMetadataExtractor()\r\n})\r\n\r\n// Service Workerの登録\r\nregisterServiceWorker()\r\n"],"names":["PNGAnalyzer","colorTypes","readBytes","file","start","length","slice","buffer","arrayBuffer","Uint8Array","bytesToUint32","bytes","offset","b0","b1","b2","b3","bytesToUint16","bytesToString","end","Array","from","map","b","String","fromCharCode","join","bytesToHex","toString","padStart","parseIHDR","data","Error","bitDepth","colorTypeValue","compressionMethod","filterMethod","interlaceMethod","width","this","height","colorType","parseTextChunk","chunkType","result","nullIndex","indexOf","keyword","text","parts","i","push","compressionFlagByte","undefined","compressionFlag","languageTag","translatedKeyword","language","compressed","error","parseTime","year","month","day","hour","minute","second","datetime","analyze","signature","expectedSignature","metadata","fileName","name","fileSize","size","chunks","imageInfo","textMetadata","timestamp","physicalDimensions","rawChunks","header","type","crcBytes","crc","chunkInfo","dataPreview","Math","min","includes","textData","Object","assign","ImagePreview","constructor","container","zoom","position","x","y","isDragging","dragStart","imageElement","naturalSize","render","imageUrl","innerHTML","formatFileSize","setupEventListeners","image","document","getElementById","viewport","onload","naturalWidth","naturalHeight","naturalSizeEl","aspectRatioEl","textContent","calculateAspectRatio","colorAnalysisEl","style","display","analyzeColors","zoomInBtn","zoomOutBtn","resetZoomBtn","downloadBtn","onclick","updateImageTransform","updateZoomDisplay","max","link","createElement","href","download","click","onmousedown","e","clientX","clientY","cursor","onmousemove","onmouseup","onmouseleave","transform","zoomBadge","zoomInfo","zoomPercent","round","disabled","gcd","a","divisor","toFixed","canvas","ctx","getContext","drawImage","getImageData","colorMap","Map","totalR","totalG","totalB","pixelCount","r","g","groupedR","floor","colorKey","set","get","averageColor","dominantColors","entries","sort","color","displayColorAnalysis","console","avgColorEl","toLocaleString","dominantContainer","rgb","match","rgbValues","at","PNGMetadataExtractor","currentMetadata","currentImageUrl","analyzer","previewContainer","imagePreview","initializeEventListeners","uploadArea","uploadButton","fileInput","exportButton","addEventListener","target","files","handleFile","preventDefault","classList","add","remove","dataTransfer","exportResults","querySelectorAll","forEach","button","tabName","dataset","tab","switchTab","showLoading","hideError","URL","revokeObjectURL","createObjectURL","displayResults","errorMessage","message","showError","resultsEl","fileSizeEl","dimensionsEl","colorTypeEl","chunkCountEl","updateImageInfo","updateChunks","updateMetadata","updateTimestamp","updateRawData","displayJSONTree","key","value","translateImageInfoKey","chunk","keys","JSON","stringify","filter","translateTimestampKey","parentElement","options","DEFAULT_JSON_VIEW_OPTIONS","showLen","showType","showBrackets","showFoldmarker","colors","boolean","null","string","number","float","className","mergedOptions","treeView","jsnview","appendChild","activeTab","querySelector","content","activeContent","dataStr","dataBlob","Blob","url","show","loadingEl","errorElement","navigator","window","serviceWorker","register","then","registration","log","scope","catch"],"sourceRoot":""}